#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/**
 * Perform a non-blocking TCP connect with a timeout.
 * Returns 0 on success, -1 on failure.
 */
int tcp_connect_timeout(const char *ip_address, int port, int timeout_sec) {
    int sockfd;
    struct sockaddr_in server_addr;
    long flags;
    int error = 0;
    socklen_t len;
    int res;
    fd_set write_fds;
    struct timeval tv;

    // 1. Create a socket
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        return -1;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    if (inet_pton(AF_INET, ip_address, &server_addr.sin_addr) <= 0) {
        perror("inet_pton");
        close(sockfd);
        return -1;
    }

    // 2. Set the socket to non-blocking mode
    flags = fcntl(sockfd, F_GETFL, NULL);
    if (flags < 0) {
        perror("fcntl(F_GETFL)");
        close(sockfd);
        return -1;
    }
    if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror("fcntl(F_SETFL)");
        close(sockfd);
        return -1;
    }

    // 3. Initiate the non-blocking connect()
    res = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if (res < 0) {
        if (errno != EINPROGRESS) {
            // A non-recoverable error occurred
            perror("connect");
            close(sockfd);
            return -1;
        }
    }

    // If connect returns 0, the connection is already established
    if (res == 0) {
        // Optional: Revert to blocking mode
        fcntl(sockfd, F_SETFL, flags);
        printf("Connection established immediately.\n");
        return sockfd;
    }

    // 4. Wait for the connection to complete with a timeout using select()
    FD_ZERO(&write_fds);
    FD_SET(sockfd, &write_fds);

    tv.tv_sec = timeout_sec;
    tv.tv_usec = 0;

    res = select(sockfd + 1, NULL, &write_fds, NULL, &tv);
    if (res < 0) {
        perror("select");
        close(sockfd);
        return -1;
    } else if (res == 0) {
        // Timeout occurred
        printf("Connect timeout after %d seconds.\n", timeout_sec);
        close(sockfd);
        errno = ETIMEDOUT;
        return -1;
    }

    // 5. Check the connection status and retrieve any errors
    len = sizeof(error);
    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {
        perror("getsockopt");
        close(sockfd);
        return -1;
    }

    if (error != 0) {
        // The connection failed
        fprintf(stderr, "Connect failed with error: %s\n", strerror(error));
        close(sockfd);
        return -1;
    }

    // Connection was successful, optionally revert to blocking mode
    printf("Connection established successfully.\n");
    fcntl(sockfd, F_SETFL, flags); // Restore original flags
    return sockfd;
}

int main() {
    // Example usage
    int connected_socket;

    printf("Attempting non-blocking connect to localhost:8080 with 5s timeout...\n");
    connected_socket = tcp_connect_timeout("127.0.0.1", 8080, 5);

    if (connected_socket != -1) {
        printf("Successfully connected. Socket descriptor: %d\n", connected_socket);
        close(connected_socket);
    } else {
        fprintf(stderr, "Failed to connect to the server.\n");
    }

    return 0;
}

hiredis
#include <stdio.h>
#include <stdlib.h>
#include <hiredis/hiredis.h>

int main() {
    // Подключение к Redis
    redisContext *c = redisConnect("127.0.0.1", 6379);
    if (c == NULL || c->err) {
        if (c) {
            printf("Ошибка подключения: %s\n", c->errstr);
            redisFree(c);
        } else {
            printf("Не удалось выделить контекст Redis\n");
        }
        exit(1);
    }
    printf("Подключение к Redis успешно!\n");

    // Пример 1: Добавление IP в очередь ip_queue
    redisReply *reply = redisCommand(c, "LPUSH ip_queue %s", "1.2.3.4:1194");
    printf("LPUSH reply: %lld\n", reply->integer);
    freeReplyObject(reply);

    // Пример 2: Получение IP из очереди
    reply = redisCommand(c, "RPOP ip_queue");
    if (reply->type == REDIS_REPLY_STRING) {
        printf("Достали из очереди: %s\n", reply->str);
    } else {
        printf("Очередь пуста или ошибка\n");
    }
    freeReplyObject(reply);

    // Пример 3: Сохранение метрик через Hash
    reply = redisCommand(c, "HMSET ip:metrics:1.2.3.4 state %s rtt %d packet_loss %d throughput %d last_checked %lld fail_count %d",
                         "alive", 120, 3, 500, (long long)time(NULL), 0);
    printf("HMSET reply: %s\n", reply->str);
    freeReplyObject(reply);

    // Пример 4: Получение всех полей
    reply = redisCommand(c, "HGETALL ip:metrics:1.2.3.4");
    if (reply->type == REDIS_REPLY_ARRAY) {
        for (size_t i = 0; i < reply->elements; i += 2) {
            printf("%s: %s\n", reply->element[i]->str, reply->element[i+1]->str);
        }
    }
    freeReplyObject(reply);

    // Закрываем соединение
    redisFree(c);
    return 0;
}
